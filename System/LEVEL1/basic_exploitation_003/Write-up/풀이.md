# 목차
1. 문제 설명

    1.1. Description

    1.2. Environment

2. 문제 파일 분석

    2.1. 코드 분석

    2.2. 실행 파일 분석

3. 문제 풀이 코드

## 1. 문제 설명

### 1.1. Description

이 문제는 서버에서 작동하고 있는 서비스(basic_exploitation_003)의 바이너리와 소스 코드가 주어집니다.

프로그램의 취약점을 찾고 익스플로잇해 "flag" 파일을 읽으세요.

"flag" 파일의 내용을 워게임 사이트에 인증하면 점수를 획득할 수 있습니다.

플래그의 형식은 DH{...} 입니다.

### 1.2. Environment

Ubuntu 16.04

Arch:     i386-32-little

RELRO:    Partial RELRO

Stack:    No canary found

NX:       NX enabled

PIE:      No PIE (0x8048000)

## 2. 문제 파일 분석

### 2.1. 코드 분석

`cat basic_exploitation_003.c`를 통해 코드를 확인
```
// basic_exploitation_003.c //

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}
void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    signal(SIGALRM, alarm_handler);
    alarm(30);
}
void get_shell() {
    system("/bin/sh");
}
int main(int argc, char *argv[]) {
    char *heap_buf = (char *)malloc(0x80);
    char stack_buf[0x90] = {};
    initialize();
    read(0, heap_buf, 0x80);
    sprintf(stack_buf, heap_buf);
    printf("ECHO : %s\n", stack_buf);
    return 0;
}
```
- 주요 기능
    - `main`함수가 실행
    - 힙 메모리에 `heap_buf`에 `0x80(128)byte`의 공간을 부여
    - 스택 메모리에 `stack_buf`에 `0x90(144)byte`의 공간을 부여
    - `read`함수를 통해 `heap_buf`을 입력 받음
    - `sprintf`함수를 통해 `heap_buf`을 `stack_buf`에 저장
    - `get_shell`함수가 실행되면 `/bin/sh`을 실행

- 주의
    - `sprintf`함수가 `heap_buf`의 내용을 그대로 사용
    -  메모리 내용이 유출되거나, 메모리 값을 임의로 변경 가능
    - `gets`함수의 버퍼를 다 채울 경우 `null`이 들어갈 수 없어 오류 발생

- 발생 가능한 취약점
    - **포맷 스트링 취약점 (Format String Vulnerability)**
    - **스택 오버플로우(Stack Buffer OverFlow)**

즉, `sprintf`함수를 통해 `stack_buf`를 오버플로우를 시켜 스택에 있는 복귀 주소가 저장되어있는 `ret`에 `get_shell`함수의 주소를 넣는 **ROP(Retrun Oriented Programming)**가 발생 가능

### 2.2. 실행 파일 분석

`gdb ./basic_exploitation_003`를 통해 GNU 디버거를 실행

`disass main`를 통해 `main`함수의 어셈블리 확인
```
Dump of assembler code for function main:
   0x0804867c <+0>:     push   ebp
   0x0804867d <+1>:     mov    ebp,esp
   0x0804867f <+3>:     push   edi
   0x08048680 <+4>:     sub    esp,0x94
   0x08048686 <+10>:    push   0x80
   0x0804868b <+15>:    call   0x8048490 <malloc@plt>
   0x08048690 <+20>:    add    esp,0x4
   0x08048693 <+23>:    mov    DWORD PTR [ebp-0x8],eax
   0x08048696 <+26>:    lea    edx,[ebp-0x98]
   0x0804869c <+32>:    mov    eax,0x0
   0x080486a1 <+37>:    mov    ecx,0x24
   0x080486a6 <+42>:    mov    edi,edx
   0x080486a8 <+44>:    rep stos DWORD PTR es:[edi],eax
   0x080486aa <+46>:    call   0x8048622 <initialize>
   0x080486af <+51>:    push   0x80
   0x080486b4 <+56>:    push   DWORD PTR [ebp-0x8]
   0x080486b7 <+59>:    push   0x0
   0x080486b9 <+61>:    call   0x8048450 <read@plt>
   0x080486be <+66>:    add    esp,0xc
   0x080486c1 <+69>:    push   DWORD PTR [ebp-0x8]
   0x080486c4 <+72>:    lea    eax,[ebp-0x98]
   0x080486ca <+78>:    push   eax
   0x080486cb <+79>:    call   0x80484f0 <sprintf@plt>
   0x080486d0 <+84>:    add    esp,0x8
   0x080486d3 <+87>:    lea    eax,[ebp-0x98]
   0x080486d9 <+93>:    push   eax
   0x080486da <+94>:    push   0x8048791
   0x080486df <+99>:    call   0x8048460 <printf@plt>
   0x080486e4 <+104>:   add    esp,0x8
   0x080486e7 <+107>:   mov    eax,0x0
   0x080486ec <+112>:   mov    edi,DWORD PTR [ebp-0x4]
   0x080486ef <+115>:   leave
   0x080486f0 <+116>:   ret
End of assembler dump.
```


`"x/i get_shell" or "disass get_shell"`등을 입력

`0x8048669 <get_shell>:       push   ebp`

`ret`에 들어갈 `get_shell`함수의 주소 확인











## 3. 문제 풀이 코드

```

```